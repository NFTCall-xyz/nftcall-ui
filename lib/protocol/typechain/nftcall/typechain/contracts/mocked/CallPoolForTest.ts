/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type { EventFragment, FunctionFragment, Result } from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'

import type { OnEvent, PromiseOrValue, TypedEvent, TypedEventFilter, TypedListener } from '../../common'

export declare namespace DataTypes {
  export type NFTStatusOutputStruct = {
    ifOnMarket: PromiseOrValue<boolean>
    minimumStrikeGapIdx: PromiseOrValue<BigNumberish>
    maximumDurationIdx: PromiseOrValue<BigNumberish>
    exerciseTime: PromiseOrValue<BigNumberish>
    endTime: PromiseOrValue<BigNumberish>
    minimumStrikePrice: PromiseOrValue<BigNumberish>
    strikePrice: PromiseOrValue<BigNumberish>
  }

  export type NFTStatusOutputStructOutput = [boolean, number, number, BigNumber, BigNumber, BigNumber, BigNumber] & {
    ifOnMarket: boolean
    minimumStrikeGapIdx: number
    maximumDurationIdx: number
    exerciseTime: BigNumber
    endTime: BigNumber
    minimumStrikePrice: BigNumber
    strikePrice: BigNumber
  }
}

export interface CallPoolForTestInterface extends utils.Interface {
  functions: {
    'DECIMALS()': FunctionFragment
    'DURATION(uint8)': FunctionFragment
    'INVALID_PRICE()': FunctionFragment
    'MAXIMUM_STRIKE_PRICE()': FunctionFragment
    'STRIKE_PRICE_GAP(uint8)': FunctionFragment
    'activate()': FunctionFragment
    'balanceOf(address)': FunctionFragment
    'callToken()': FunctionFragment
    'changePreference(uint256,uint8,uint8,uint256)': FunctionFragment
    'changePreferenceBatch(uint256[],uint8[],uint8[],uint256[])': FunctionFragment
    'checkAvailable(uint256)': FunctionFragment
    'collectProtocol(address,uint256)': FunctionFragment
    'deactivate()': FunctionFragment
    'deposit(address,uint256)': FunctionFragment
    'depositBatch(address,uint256[])': FunctionFragment
    'depositWithPreference(address,uint256,uint8,uint8,uint256)': FunctionFragment
    'depositWithPreferenceBatch(address,uint256[],uint8[],uint8[],uint256[])': FunctionFragment
    'exerciseCall(uint256)': FunctionFragment
    'exerciseCallBatch(uint256[])': FunctionFragment
    'exercisePeriodProportion()': FunctionFragment
    'factory()': FunctionFragment
    'getEndTime(uint256)': FunctionFragment
    'getNFTStatus(uint256)': FunctionFragment
    'getNFTStatusBatch(uint256[])': FunctionFragment
    'minimumPremiumToOwner()': FunctionFragment
    'nToken()': FunctionFragment
    'nft()': FunctionFragment
    'openCall(uint256,uint8,uint8)': FunctionFragment
    'openCallBatch(uint256[],uint8[],uint8[])': FunctionFragment
    'oracle()': FunctionFragment
    'pause()': FunctionFragment
    'paused()': FunctionFragment
    'premium()': FunctionFragment
    'previewOpenCall(uint256,uint8,uint8)': FunctionFragment
    'previewOpenCallBatch(uint256[],uint8[],uint8[])': FunctionFragment
    'relistNFT(uint256)': FunctionFragment
    'relistNFTBatch(uint256[])': FunctionFragment
    'takeNFTOffMarket(uint256)': FunctionFragment
    'takeNFTOffMarketBatch(uint256[])': FunctionFragment
    'totalOpenInterest()': FunctionFragment
    'transferERC721(address,address,uint256)': FunctionFragment
    'unpause()': FunctionFragment
    'withdraw(address,uint256)': FunctionFragment
    'withdrawBatch(address,uint256[])': FunctionFragment
    'withdrawETH(address,uint256)': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'DECIMALS'
      | 'DURATION'
      | 'INVALID_PRICE'
      | 'MAXIMUM_STRIKE_PRICE'
      | 'STRIKE_PRICE_GAP'
      | 'activate'
      | 'balanceOf'
      | 'callToken'
      | 'changePreference'
      | 'changePreferenceBatch'
      | 'checkAvailable'
      | 'collectProtocol'
      | 'deactivate'
      | 'deposit'
      | 'depositBatch'
      | 'depositWithPreference'
      | 'depositWithPreferenceBatch'
      | 'exerciseCall'
      | 'exerciseCallBatch'
      | 'exercisePeriodProportion'
      | 'factory'
      | 'getEndTime'
      | 'getNFTStatus'
      | 'getNFTStatusBatch'
      | 'minimumPremiumToOwner'
      | 'nToken'
      | 'nft'
      | 'openCall'
      | 'openCallBatch'
      | 'oracle'
      | 'pause'
      | 'paused'
      | 'premium'
      | 'previewOpenCall'
      | 'previewOpenCallBatch'
      | 'relistNFT'
      | 'relistNFTBatch'
      | 'takeNFTOffMarket'
      | 'takeNFTOffMarketBatch'
      | 'totalOpenInterest'
      | 'transferERC721'
      | 'unpause'
      | 'withdraw'
      | 'withdrawBatch'
      | 'withdrawETH'
  ): FunctionFragment

  encodeFunctionData(functionFragment: 'DECIMALS', values?: undefined): string
  encodeFunctionData(functionFragment: 'DURATION', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'INVALID_PRICE', values?: undefined): string
  encodeFunctionData(functionFragment: 'MAXIMUM_STRIKE_PRICE', values?: undefined): string
  encodeFunctionData(functionFragment: 'STRIKE_PRICE_GAP', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'activate', values?: undefined): string
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string
  encodeFunctionData(functionFragment: 'callToken', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'changePreference',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'changePreferenceBatch',
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string
  encodeFunctionData(functionFragment: 'checkAvailable', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(
    functionFragment: 'collectProtocol',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(functionFragment: 'deactivate', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'depositBatch',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[]]
  ): string
  encodeFunctionData(
    functionFragment: 'depositWithPreference',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'depositWithPreferenceBatch',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string
  encodeFunctionData(functionFragment: 'exerciseCall', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'exerciseCallBatch', values: [PromiseOrValue<BigNumberish>[]]): string
  encodeFunctionData(functionFragment: 'exercisePeriodProportion', values?: undefined): string
  encodeFunctionData(functionFragment: 'factory', values?: undefined): string
  encodeFunctionData(functionFragment: 'getEndTime', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'getNFTStatus', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'getNFTStatusBatch', values: [PromiseOrValue<BigNumberish>[]]): string
  encodeFunctionData(functionFragment: 'minimumPremiumToOwner', values?: undefined): string
  encodeFunctionData(functionFragment: 'nToken', values?: undefined): string
  encodeFunctionData(functionFragment: 'nft', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'openCall',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'openCallBatch',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string
  encodeFunctionData(functionFragment: 'oracle', values?: undefined): string
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string
  encodeFunctionData(functionFragment: 'premium', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'previewOpenCall',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'previewOpenCallBatch',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string
  encodeFunctionData(functionFragment: 'relistNFT', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'relistNFTBatch', values: [PromiseOrValue<BigNumberish>[]]): string
  encodeFunctionData(functionFragment: 'takeNFTOffMarket', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'takeNFTOffMarketBatch', values: [PromiseOrValue<BigNumberish>[]]): string
  encodeFunctionData(functionFragment: 'totalOpenInterest', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'transferERC721',
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'withdrawBatch',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[]]
  ): string
  encodeFunctionData(
    functionFragment: 'withdrawETH',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string

  decodeFunctionResult(functionFragment: 'DECIMALS', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'DURATION', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'INVALID_PRICE', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'MAXIMUM_STRIKE_PRICE', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'STRIKE_PRICE_GAP', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'activate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'callToken', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'changePreference', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'changePreferenceBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'checkAvailable', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'collectProtocol', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'deactivate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'depositBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'depositWithPreference', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'depositWithPreferenceBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'exerciseCall', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'exerciseCallBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'exercisePeriodProportion', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'factory', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getEndTime', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getNFTStatus', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getNFTStatusBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'minimumPremiumToOwner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'nToken', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'nft', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'openCall', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'openCallBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'oracle', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'premium', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'previewOpenCall', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'previewOpenCallBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'relistNFT', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'relistNFTBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'takeNFTOffMarket', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'takeNFTOffMarketBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'totalOpenInterest', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'transferERC721', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'withdrawBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'withdrawETH', data: BytesLike): Result

  events: {
    'Activate(address)': EventFragment
    'BalanceChangedETH(address,uint256)': EventFragment
    'CallClosed(address,address,address,uint256,uint256)': EventFragment
    'CallOpened(address,address,uint256,uint8,uint8,uint256,uint40,uint40)': EventFragment
    'CollectProtocol(address,address,uint256)': EventFragment
    'Deactivate(address)': EventFragment
    'Deposit(address,address,address,uint256)': EventFragment
    'OffMarket(address,address,uint256)': EventFragment
    'OnMarket(address,address,uint256)': EventFragment
    'Paused(address)': EventFragment
    'PreferenceUpdated(address,uint256,uint8,uint8,uint256)': EventFragment
    'PremiumReceived(address,address,uint256,uint256,uint256)': EventFragment
    'Unpaused(address)': EventFragment
    'Withdraw(address,address,address,uint256)': EventFragment
    'WithdrawETH(address,address,uint256)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'Activate'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'BalanceChangedETH'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'CallClosed'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'CallOpened'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'CollectProtocol'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Deactivate'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Deposit'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'OffMarket'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'OnMarket'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'PreferenceUpdated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'PremiumReceived'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Withdraw'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'WithdrawETH'): EventFragment
}

export interface ActivateEventObject {
  account: string
}
export type ActivateEvent = TypedEvent<[string], ActivateEventObject>

export type ActivateEventFilter = TypedEventFilter<ActivateEvent>

export interface BalanceChangedETHEventObject {
  user: string
  newBalance: BigNumber
}
export type BalanceChangedETHEvent = TypedEvent<[string, BigNumber], BalanceChangedETHEventObject>

export type BalanceChangedETHEventFilter = TypedEventFilter<BalanceChangedETHEvent>

export interface CallClosedEventObject {
  nft: string
  user: string
  owner: string
  tokenId: BigNumber
  price: BigNumber
}
export type CallClosedEvent = TypedEvent<[string, string, string, BigNumber, BigNumber], CallClosedEventObject>

export type CallClosedEventFilter = TypedEventFilter<CallClosedEvent>

export interface CallOpenedEventObject {
  nft: string
  user: string
  tokenId: BigNumber
  strikePriceGapIdx: number
  durationIdx: number
  exercisePrice: BigNumber
  exercisePeriodBegin: number
  exercisePeriodEnd: number
}
export type CallOpenedEvent = TypedEvent<
  [string, string, BigNumber, number, number, BigNumber, number, number],
  CallOpenedEventObject
>

export type CallOpenedEventFilter = TypedEventFilter<CallOpenedEvent>

export interface CollectProtocolEventObject {
  sender: string
  recipient: string
  amount: BigNumber
}
export type CollectProtocolEvent = TypedEvent<[string, string, BigNumber], CollectProtocolEventObject>

export type CollectProtocolEventFilter = TypedEventFilter<CollectProtocolEvent>

export interface DeactivateEventObject {
  account: string
}
export type DeactivateEvent = TypedEvent<[string], DeactivateEventObject>

export type DeactivateEventFilter = TypedEventFilter<DeactivateEvent>

export interface DepositEventObject {
  nft: string
  user: string
  onBehalfOf: string
  tokenId: BigNumber
}
export type DepositEvent = TypedEvent<[string, string, string, BigNumber], DepositEventObject>

export type DepositEventFilter = TypedEventFilter<DepositEvent>

export interface OffMarketEventObject {
  nft: string
  owner: string
  tokenId: BigNumber
}
export type OffMarketEvent = TypedEvent<[string, string, BigNumber], OffMarketEventObject>

export type OffMarketEventFilter = TypedEventFilter<OffMarketEvent>

export interface OnMarketEventObject {
  nft: string
  owner: string
  tokenId: BigNumber
}
export type OnMarketEvent = TypedEvent<[string, string, BigNumber], OnMarketEventObject>

export type OnMarketEventFilter = TypedEventFilter<OnMarketEvent>

export interface PausedEventObject {
  account: string
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>

export type PausedEventFilter = TypedEventFilter<PausedEvent>

export interface PreferenceUpdatedEventObject {
  nft: string
  tokenId: BigNumber
  lowerStrikePriceGapIdx: number
  upperDurationIdx: number
  minimumStrikePrice: BigNumber
}
export type PreferenceUpdatedEvent = TypedEvent<
  [string, BigNumber, number, number, BigNumber],
  PreferenceUpdatedEventObject
>

export type PreferenceUpdatedEventFilter = TypedEventFilter<PreferenceUpdatedEvent>

export interface PremiumReceivedEventObject {
  nft: string
  owner: string
  tokenId: BigNumber
  premiumToOwner: BigNumber
  premiumToReserve: BigNumber
}
export type PremiumReceivedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  PremiumReceivedEventObject
>

export type PremiumReceivedEventFilter = TypedEventFilter<PremiumReceivedEvent>

export interface UnpausedEventObject {
  account: string
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>

export interface WithdrawEventObject {
  nft: string
  user: string
  to: string
  tokenId: BigNumber
}
export type WithdrawEvent = TypedEvent<[string, string, string, BigNumber], WithdrawEventObject>

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>

export interface WithdrawETHEventObject {
  user: string
  to: string
  amount: BigNumber
}
export type WithdrawETHEvent = TypedEvent<[string, string, BigNumber], WithdrawETHEventObject>

export type WithdrawETHEventFilter = TypedEventFilter<WithdrawETHEvent>

export interface CallPoolForTest extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: CallPoolForTestInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    DECIMALS(overrides?: CallOverrides): Promise<[BigNumber]>

    DURATION(durationIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[number]>

    INVALID_PRICE(overrides?: CallOverrides): Promise<[BigNumber]>

    MAXIMUM_STRIKE_PRICE(overrides?: CallOverrides): Promise<[BigNumber]>

    STRIKE_PRICE_GAP(strikePriceGapIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>

    activate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>

    callToken(overrides?: CallOverrides): Promise<[string]>

    changePreference(
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    changePreferenceBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    checkAvailable(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>

    collectProtocol(
      recipient: PromiseOrValue<string>,
      amountRequested: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    deactivate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

    deposit(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    depositBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    depositWithPreference(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    depositWithPreferenceBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    exerciseCall(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    exerciseCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    exercisePeriodProportion(overrides?: CallOverrides): Promise<[number]>

    factory(overrides?: CallOverrides): Promise<[string]>

    getEndTime(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>

    getNFTStatus(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[DataTypes.NFTStatusOutputStructOutput]>

    getNFTStatusBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[DataTypes.NFTStatusOutputStructOutput[]]>

    minimumPremiumToOwner(overrides?: CallOverrides): Promise<[BigNumber]>

    nToken(overrides?: CallOverrides): Promise<[string]>

    nft(overrides?: CallOverrides): Promise<[string]>

    openCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    openCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    oracle(overrides?: CallOverrides): Promise<[string]>

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

    paused(overrides?: CallOverrides): Promise<[boolean]>

    premium(overrides?: CallOverrides): Promise<[string]>

    previewOpenCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        strikePrice: BigNumber
        premiumToOwner: BigNumber
        premiumToReserve: BigNumber
        errorCode: BigNumber
      }
    >

    previewOpenCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[], BigNumber[], BigNumber[]] & {
        strikePrices: BigNumber[]
        premiumsToOwner: BigNumber[]
        premiumsToReserve: BigNumber[]
        errorCodes: BigNumber[]
      }
    >

    relistNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    relistNFTBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    takeNFTOffMarket(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    takeNFTOffMarketBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    totalOpenInterest(overrides?: CallOverrides): Promise<[BigNumber]>

    transferERC721(
      collection: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

    withdraw(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    withdrawBatch(
      to: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    withdrawETH(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>
  }

  DECIMALS(overrides?: CallOverrides): Promise<BigNumber>

  DURATION(durationIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>

  INVALID_PRICE(overrides?: CallOverrides): Promise<BigNumber>

  MAXIMUM_STRIKE_PRICE(overrides?: CallOverrides): Promise<BigNumber>

  STRIKE_PRICE_GAP(strikePriceGapIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

  activate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

  balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

  callToken(overrides?: CallOverrides): Promise<string>

  changePreference(
    tokenId: PromiseOrValue<BigNumberish>,
    lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
    upperDurationIdx: PromiseOrValue<BigNumberish>,
    minimumStrikePrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  changePreferenceBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
    upperDurationIdxList: PromiseOrValue<BigNumberish>[],
    minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  checkAvailable(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>

  collectProtocol(
    recipient: PromiseOrValue<string>,
    amountRequested: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  deactivate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

  deposit(
    onBehalfOf: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  depositBatch(
    onBehalfOf: PromiseOrValue<string>,
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  depositWithPreference(
    onBehalfOf: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
    upperDurationIdx: PromiseOrValue<BigNumberish>,
    minimumStrikePrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  depositWithPreferenceBatch(
    onBehalfOf: PromiseOrValue<string>,
    tokenIds: PromiseOrValue<BigNumberish>[],
    lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
    upperDurationIdxList: PromiseOrValue<BigNumberish>[],
    minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  exerciseCall(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  exerciseCallBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  exercisePeriodProportion(overrides?: CallOverrides): Promise<number>

  factory(overrides?: CallOverrides): Promise<string>

  getEndTime(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

  getNFTStatus(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<DataTypes.NFTStatusOutputStructOutput>

  getNFTStatusBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<DataTypes.NFTStatusOutputStructOutput[]>

  minimumPremiumToOwner(overrides?: CallOverrides): Promise<BigNumber>

  nToken(overrides?: CallOverrides): Promise<string>

  nft(overrides?: CallOverrides): Promise<string>

  openCall(
    tokenId: PromiseOrValue<BigNumberish>,
    strikePriceGapIdx: PromiseOrValue<BigNumberish>,
    durationIdx: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  openCallBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    strikePriceGaps: PromiseOrValue<BigNumberish>[],
    durations: PromiseOrValue<BigNumberish>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  oracle(overrides?: CallOverrides): Promise<string>

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

  paused(overrides?: CallOverrides): Promise<boolean>

  premium(overrides?: CallOverrides): Promise<string>

  previewOpenCall(
    tokenId: PromiseOrValue<BigNumberish>,
    strikePriceGapIdx: PromiseOrValue<BigNumberish>,
    durationIdx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      strikePrice: BigNumber
      premiumToOwner: BigNumber
      premiumToReserve: BigNumber
      errorCode: BigNumber
    }
  >

  previewOpenCallBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    strikePriceGaps: PromiseOrValue<BigNumberish>[],
    durations: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[], BigNumber[], BigNumber[]] & {
      strikePrices: BigNumber[]
      premiumsToOwner: BigNumber[]
      premiumsToReserve: BigNumber[]
      errorCodes: BigNumber[]
    }
  >

  relistNFT(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  relistNFTBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  takeNFTOffMarket(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  takeNFTOffMarketBatch(
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  totalOpenInterest(overrides?: CallOverrides): Promise<BigNumber>

  transferERC721(
    collection: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

  withdraw(
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  withdrawBatch(
    to: PromiseOrValue<string>,
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  withdrawETH(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  callStatic: {
    DECIMALS(overrides?: CallOverrides): Promise<BigNumber>

    DURATION(durationIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>

    INVALID_PRICE(overrides?: CallOverrides): Promise<BigNumber>

    MAXIMUM_STRIKE_PRICE(overrides?: CallOverrides): Promise<BigNumber>

    STRIKE_PRICE_GAP(strikePriceGapIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    activate(overrides?: CallOverrides): Promise<void>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

    callToken(overrides?: CallOverrides): Promise<string>

    changePreference(
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    changePreferenceBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    checkAvailable(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>

    collectProtocol(
      recipient: PromiseOrValue<string>,
      amountRequested: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    deactivate(overrides?: CallOverrides): Promise<void>

    deposit(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    depositBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    depositWithPreference(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    depositWithPreferenceBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    exerciseCall(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>

    exerciseCallBatch(tokenIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber[]>

    exercisePeriodProportion(overrides?: CallOverrides): Promise<number>

    factory(overrides?: CallOverrides): Promise<string>

    getEndTime(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    getNFTStatus(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<DataTypes.NFTStatusOutputStructOutput>

    getNFTStatusBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<DataTypes.NFTStatusOutputStructOutput[]>

    minimumPremiumToOwner(overrides?: CallOverrides): Promise<BigNumber>

    nToken(overrides?: CallOverrides): Promise<string>

    nft(overrides?: CallOverrides): Promise<string>

    openCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    openCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>

    oracle(overrides?: CallOverrides): Promise<string>

    pause(overrides?: CallOverrides): Promise<void>

    paused(overrides?: CallOverrides): Promise<boolean>

    premium(overrides?: CallOverrides): Promise<string>

    previewOpenCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        strikePrice: BigNumber
        premiumToOwner: BigNumber
        premiumToReserve: BigNumber
        errorCode: BigNumber
      }
    >

    previewOpenCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[], BigNumber[], BigNumber[]] & {
        strikePrices: BigNumber[]
        premiumsToOwner: BigNumber[]
        premiumsToReserve: BigNumber[]
        errorCodes: BigNumber[]
      }
    >

    relistNFT(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>

    relistNFTBatch(tokenIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber[]>

    takeNFTOffMarket(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>

    takeNFTOffMarketBatch(tokenIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber[]>

    totalOpenInterest(overrides?: CallOverrides): Promise<BigNumber>

    transferERC721(
      collection: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    unpause(overrides?: CallOverrides): Promise<void>

    withdraw(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    withdrawBatch(
      to: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    withdrawETH(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>
  }

  filters: {
    'Activate(address)'(account?: null): ActivateEventFilter
    Activate(account?: null): ActivateEventFilter

    'BalanceChangedETH(address,uint256)'(
      user?: PromiseOrValue<string> | null,
      newBalance?: null
    ): BalanceChangedETHEventFilter
    BalanceChangedETH(user?: PromiseOrValue<string> | null, newBalance?: null): BalanceChangedETHEventFilter

    'CallClosed(address,address,address,uint256,uint256)'(
      nft?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      owner?: null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      price?: null
    ): CallClosedEventFilter
    CallClosed(
      nft?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      owner?: null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      price?: null
    ): CallClosedEventFilter

    'CallOpened(address,address,uint256,uint8,uint8,uint256,uint40,uint40)'(
      nft?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      strikePriceGapIdx?: null,
      durationIdx?: null,
      exercisePrice?: null,
      exercisePeriodBegin?: null,
      exercisePeriodEnd?: null
    ): CallOpenedEventFilter
    CallOpened(
      nft?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      strikePriceGapIdx?: null,
      durationIdx?: null,
      exercisePrice?: null,
      exercisePeriodBegin?: null,
      exercisePeriodEnd?: null
    ): CallOpenedEventFilter

    'CollectProtocol(address,address,uint256)'(
      sender?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      amount?: null
    ): CollectProtocolEventFilter
    CollectProtocol(
      sender?: PromiseOrValue<string> | null,
      recipient?: PromiseOrValue<string> | null,
      amount?: null
    ): CollectProtocolEventFilter

    'Deactivate(address)'(account?: null): DeactivateEventFilter
    Deactivate(account?: null): DeactivateEventFilter

    'Deposit(address,address,address,uint256)'(
      nft?: PromiseOrValue<string> | null,
      user?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): DepositEventFilter
    Deposit(
      nft?: PromiseOrValue<string> | null,
      user?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): DepositEventFilter

    'OffMarket(address,address,uint256)'(
      nft?: PromiseOrValue<string> | null,
      owner?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): OffMarketEventFilter
    OffMarket(
      nft?: PromiseOrValue<string> | null,
      owner?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): OffMarketEventFilter

    'OnMarket(address,address,uint256)'(
      nft?: PromiseOrValue<string> | null,
      owner?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): OnMarketEventFilter
    OnMarket(
      nft?: PromiseOrValue<string> | null,
      owner?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): OnMarketEventFilter

    'Paused(address)'(account?: null): PausedEventFilter
    Paused(account?: null): PausedEventFilter

    'PreferenceUpdated(address,uint256,uint8,uint8,uint256)'(
      nft?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      lowerStrikePriceGapIdx?: null,
      upperDurationIdx?: null,
      minimumStrikePrice?: null
    ): PreferenceUpdatedEventFilter
    PreferenceUpdated(
      nft?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      lowerStrikePriceGapIdx?: null,
      upperDurationIdx?: null,
      minimumStrikePrice?: null
    ): PreferenceUpdatedEventFilter

    'PremiumReceived(address,address,uint256,uint256,uint256)'(
      nft?: PromiseOrValue<string> | null,
      owner?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      premiumToOwner?: null,
      premiumToReserve?: null
    ): PremiumReceivedEventFilter
    PremiumReceived(
      nft?: PromiseOrValue<string> | null,
      owner?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null,
      premiumToOwner?: null,
      premiumToReserve?: null
    ): PremiumReceivedEventFilter

    'Unpaused(address)'(account?: null): UnpausedEventFilter
    Unpaused(account?: null): UnpausedEventFilter

    'Withdraw(address,address,address,uint256)'(
      nft?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      to?: null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): WithdrawEventFilter
    Withdraw(
      nft?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      to?: null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): WithdrawEventFilter

    'WithdrawETH(address,address,uint256)'(
      user?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null
    ): WithdrawETHEventFilter
    WithdrawETH(
      user?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null
    ): WithdrawETHEventFilter
  }

  estimateGas: {
    DECIMALS(overrides?: CallOverrides): Promise<BigNumber>

    DURATION(durationIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    INVALID_PRICE(overrides?: CallOverrides): Promise<BigNumber>

    MAXIMUM_STRIKE_PRICE(overrides?: CallOverrides): Promise<BigNumber>

    STRIKE_PRICE_GAP(strikePriceGapIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    activate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

    callToken(overrides?: CallOverrides): Promise<BigNumber>

    changePreference(
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    changePreferenceBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    checkAvailable(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    collectProtocol(
      recipient: PromiseOrValue<string>,
      amountRequested: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    deactivate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>

    deposit(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    depositBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    depositWithPreference(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    depositWithPreferenceBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    exerciseCall(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    exerciseCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    exercisePeriodProportion(overrides?: CallOverrides): Promise<BigNumber>

    factory(overrides?: CallOverrides): Promise<BigNumber>

    getEndTime(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    getNFTStatus(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    getNFTStatusBatch(tokenIds: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber>

    minimumPremiumToOwner(overrides?: CallOverrides): Promise<BigNumber>

    nToken(overrides?: CallOverrides): Promise<BigNumber>

    nft(overrides?: CallOverrides): Promise<BigNumber>

    openCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    openCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    oracle(overrides?: CallOverrides): Promise<BigNumber>

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>

    paused(overrides?: CallOverrides): Promise<BigNumber>

    premium(overrides?: CallOverrides): Promise<BigNumber>

    previewOpenCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    previewOpenCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>

    relistNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    relistNFTBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    takeNFTOffMarket(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    takeNFTOffMarketBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    totalOpenInterest(overrides?: CallOverrides): Promise<BigNumber>

    transferERC721(
      collection: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>

    withdraw(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    withdrawBatch(
      to: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    withdrawETH(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>
  }

  populateTransaction: {
    DECIMALS(overrides?: CallOverrides): Promise<PopulatedTransaction>

    DURATION(durationIdx: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    INVALID_PRICE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    MAXIMUM_STRIKE_PRICE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    STRIKE_PRICE_GAP(
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    activate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    callToken(overrides?: CallOverrides): Promise<PopulatedTransaction>

    changePreference(
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    changePreferenceBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    checkAvailable(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    collectProtocol(
      recipient: PromiseOrValue<string>,
      amountRequested: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    deactivate(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>

    deposit(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    depositBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    depositWithPreference(
      onBehalfOf: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      lowerStrikePriceGapIdx: PromiseOrValue<BigNumberish>,
      upperDurationIdx: PromiseOrValue<BigNumberish>,
      minimumStrikePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    depositWithPreferenceBatch(
      onBehalfOf: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      lowerStrikePriceGapIdxList: PromiseOrValue<BigNumberish>[],
      upperDurationIdxList: PromiseOrValue<BigNumberish>[],
      minimumStrikePriceList: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    exerciseCall(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    exerciseCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    exercisePeriodProportion(overrides?: CallOverrides): Promise<PopulatedTransaction>

    factory(overrides?: CallOverrides): Promise<PopulatedTransaction>

    getEndTime(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    getNFTStatus(tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    getNFTStatusBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    minimumPremiumToOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    nToken(overrides?: CallOverrides): Promise<PopulatedTransaction>

    nft(overrides?: CallOverrides): Promise<PopulatedTransaction>

    openCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    openCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>

    premium(overrides?: CallOverrides): Promise<PopulatedTransaction>

    previewOpenCall(
      tokenId: PromiseOrValue<BigNumberish>,
      strikePriceGapIdx: PromiseOrValue<BigNumberish>,
      durationIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    previewOpenCallBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      strikePriceGaps: PromiseOrValue<BigNumberish>[],
      durations: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    relistNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    relistNFTBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    takeNFTOffMarket(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    takeNFTOffMarketBatch(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    totalOpenInterest(overrides?: CallOverrides): Promise<PopulatedTransaction>

    transferERC721(
      collection: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>

    withdraw(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    withdrawBatch(
      to: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    withdrawETH(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>
  }
}
